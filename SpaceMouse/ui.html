<code>Device status: connected</code>
<div class="viz">
  <div class="translation-meter">
    <div class="translation-meter__circle"></div>
  </div>
  <div class="zoom-meter">
    <div class="zoom-meter__bar"></div>
  </div>
</div>
<style>
  :root {
    --x: 0px;
    --y: 0px;
    --z: 0px;
  }
  .viz {
    display: grid;
    grid-template-columns: 1fr 1fr;
  }
  .translation-meter {
    width: 100px;
    height: 100px;
    border: 1px solid #ccc;
    border-radius: 50%;
    position: relative;
  }

  .translation-meter__circle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 1px solid #333;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(calc(var(--x) - 50%), calc(var(--y) - 50%));
    will-change: transform;
  }
  .zoom-meter {
    width: 10px;
    height: 100px;
    border: 1px solid #ccc;
    position: relative;
  }
  .zoom-meter__bar {
    position: absolute;
    width: 100%;
    height: 1px;
    background-color: #333;
    top: 50%;
    transform: translateY(calc(var(--z)));
  }
</style>
<script>
  class Vector2D {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    get magnitude() {
      return Math.hypot(this.x, this.y);
    }

    scaleToMagnitude(magnitude) {
      if (this.magnitude === 0) {
        return new Vector2D(0, 0);
      } else {
        const scaleFactor = magnitude / this.magnitude;
        return new Vector2D(this.x * scaleFactor, this.y * scaleFactor);
      }
    }

    scaleToFactor(factor) {
      return new Vector2D(this.x * factor, this.y * factor);
    }

    add(vector, maxMagnitude = Infinity) {
      let netX = this.x + vector.x;
      let netY = this.y + vector.y;
      const newMagnitude = Math.hypot(netX, netY);
      if (newMagnitude > maxMagnitude) {
        netX = (netX * maxMagnitude) / newMagnitude;
        netY = (netY * maxMagnitude) / newMagnitude;
      }
      return new Vector2D(netX, netY);
    }

    toString() {
      return `<x: ${this.x}, y: ${this.y}>`;
    }

    toObject() {
      return { x: this.x, y: this.y };
    }
  }

  /**
   * Gamepad API wrapper for the SpaceNavigator axes
   */
  class SpaceNavigator {
    constructor() {
      navigator.getGamepads(); // first call to trigger connection

      this.spaceNavigator = this.getSpaceNavigator();
    }

    getAxes() {
      const spaceNavigator = this.getSpaceNavigator();
      return spaceNavigator && spaceNavigator.axes ? spaceNavigator.axes : [0, 0, 0, 0, 0, 0];
    }

    getSpaceNavigator() {
      const gamepadList = [...navigator.getGamepads()];
      return gamepadList.find(gamepad => this.isSpaceMouse(gamepad));
    }

    /**
     *
     * @param {Gamepad} gamepad
     */
    isSpaceMouse(gamepad) {
      if (!gamepad) return false;
      if (!gamepad.id) return false;
      if (gamepad.id.indexOf('3Dconnexion Universal Receiver') < 0) return false;
      if (gamepad.axes.length !== 6) return false;

      return true;
    }
  }

  /**
   * calculating speed and translation at each tick
   */
  class PhysicsEngine {
    constructor() {
      this.previousTime = null;
      this.spaceNavigator = new SpaceNavigator();
      this.velocity = new Vector2D(0, 0);
      this.zoomMultiplier = 1;
      this.friction = 0.2;
      window.requestAnimationFrame(() => this.update());
    }

    update() {
      const nowTime = performance.now();
      const delta = nowTime - this.previousTime;
      this.previousTime = nowTime;
      const [fX, fY, fZ] = this.spaceNavigator.getAxes();

      this.updateVisualization(fX, fY, fZ);

      this.updateVelocity(delta, fX, fY);
      this.updateZoomMultiplier(delta, fZ);

      const translation = this.velocity.scaleToFactor(delta * 0.5);
      parent.postMessage(
        { pluginMessage: { type: 'mouse-update', x: translation.x, y: translation.y, zoom: this.zoomMultiplier } },
        '*'
      );

      window.requestAnimationFrame(() => this.update());
    }

    updateVisualization(fX, fY, fZ) {
      const root = document.documentElement;
      root.style.setProperty('--x', `${fX * 100}px`);
      root.style.setProperty('--y', `${fY * 100}px`);
      root.style.setProperty('--z', `${fZ * 50}px`);
    }

    updateVelocity(delta, fX, fY) {
      const mouseForce = new Vector2D(fX, fY);

      if (mouseForce.magnitude > 0) {
        // this.velocity = this.velocity.add(mouseForce, 5);
        this.velocity = mouseForce.scaleToFactor(20);
      } else {
        if (this.velocity.magnitude > 0.1) {
          this.velocity = this.velocity.scaleToFactor(1 / delta);
        } else {
          this.velocity = this.velocity.scaleToMagnitude(0);
        }
      }
    }

    updateZoomMultiplier(delta, fZ) {
      if (fZ > 0) {
        this.zoomMultiplier = Math.min(1 + fZ / 10, 1.05);
      } else if (fZ < 0) {
        this.zoomMultiplier = Math.max(1 + fZ / 8, 0.92);
      } else {
        this.zoomMultiplier = 1;
      }
    }
  }

  new PhysicsEngine();

  document.addEventListener('mousewheel', function(event) {
    console.log('scroll hijack');
    event.preventDefault();
  });
</script>
